#!/usr/bin/env perl

use 5.014;
use English;

use FindBin;
use lib "$FindBin::Bin/../lib";
use lib "$FindBin::Bin/../extlib/lib/perl5";

use Fluent::Agent;

my $LOGLEVEL = 'INFO';

my $HUPPED = undef;
$SIG{ HUP } = sub { $HUPPED = 1; }; # reopen/reconnect/refork
my $TERMINATED = undef;
$SIG{ INT } = $SIG{ TERM } = sub { $TERMINATED = 1; }; # terminate

my $checker_terminated = sub { $TERMINATED };
my $checker_reload = sub {
    if (shift) {
        $HUPPED = undef;
    } else {
        $HUPPED or $TERMINATED;
    }
};

use Fluent::Agent::Options;
my $opt = Fluent::Agent::Options->parse();

use Pod::Usage;
pod2usage(1) if $opt->{help};
if ($opt->{quiet}) {   $LOGLEVEL = 'WARN'; }
if ($opt->{verbose}) { $LOGLEVEL = 'DEBUG'; $ENV{LM_DEBUG} = 1; }

### Logs
use Log::Minimal;
$Log::Minimal::LOG_LEVEL = $LOGLEVEL;
$Log::Minimal::AUTODUMP = 1;
$Log::Minimal::PRINT = sub {
    my ( $time, $type, $message, $trace, $raw_message) = @_;
    print "$time [$type] ($PID) $message at $trace\n";
};
$Log::Minimal::DIE = sub {
    my ( $time, $type, $message, $trace, $raw_message) = @_;
    die "$time [$type] ($PID) $message at $trace\n";
};
croakf "Log path (-L or --log) MUST be specified when daemonized" if $opt->{daemonize} and not defined($opt->{logpath});
if (defined $opt->{logpath}) {
    my $logpath = $opt->{logpath};
    open(STDOUT, ">> $logpath") or die "failed to reopen STDOUT to $logpath";
    open(STDERR, ">> $logpath") or die "failed to reopen STDERR to $logpath";
    use IO::Handle;
    autoflush STDOUT 1;
    autoflush STDERR 1;
}

### Input options
my $input = undef;
if (defined $opt->{input_file} and defined $opt->{input_port}) {
    croakf "Cannot specify both of INPUT_FILE(-i) and INPUT_PORT(-p)";
} elsif (defined $opt->{input_file}) {
    my ($input_file, $input_pattern, $tag_string, $tag_field, $time_format, $time_field) = (
        $opt->{input_file}, $opt->{input_pattern}, $opt->{tag_string}, $opt->{tag_field}, $opt->{time_format}, $opt->{time_field},
    );
    croakf("Cannot find specified file readable: %s", $input_file) unless -f $input_file and -r $input_file;
    croakf("INPUT_PATTERN(-I) MUST be specified with INPUT_FILE(-i) option") unless defined $input_pattern;
    croakf("TAG(-t) or TAG_FIELD(-T) MUST be specified with INPUT_FILE(-i) option") unless defined $tag_string or defined $tag_field;
    $input = +{
        type => 'file',
        path => $input_file,
        pattern => qr/$input_pattern/,
        (defined $tag_string ?
             (tag_string => $tag_string)
             :
             (tag_field => $tag_field)),
        time_format => $time_format,
        time_field => ($time_field || 'time'),
    };
} elsif (defined $opt->{input_port}) {
    $input = +{ type => 'forward', port => $opt->{input_port} };
} else {
    croakf "No one input options specified";
}
debugf "Configured input: %s", $input;

### Output options
my $output = undef;
if (defined $opt->{output_file} and defined $opt->{forward_primary}) {
    croakf "Cannot specify both of OUTPUT_FILE(-o) and FORWARD_PRIMARY(-f)";
} elsif (defined $opt->{output_file}) {
    # With time specifier, we cannot check directory/file write permissions
    $output = +{
        type => 'file',
        path => $opt->{output_file},
        # format ?
    };
} elsif (defined $opt->{forward_primary}) {
    $output = +{
        type => 'forward',
        primary => [map { [split(/:/, $_)] } @{$opt->{forward_primary}}],
        secondary => [map { [split(/:/, $_)] } @{$opt->{forward_secondary} || []}],
    };
} else {
    croakf "No one output options specified";
}
debugf "Configured output: %s", $output;

### TODO Filter options
my $filter = undef;
debugf "Configured filter: %s", ($filter || 'undefined');

### Ping options
my $ping = undef;
if (defined $opt->{ping_options}) {
    my ($ping_tag,$ping_data,$ping_interval) = split(/:/, $opt->{ping_options});
    $ping_interval ||= 60;
    croakf "Ping tag is invalid" unless $ping_tag;
    croakf "Ping data is invalid" unless $ping_data;
    $ping = +{
        tag => $ping_tag,
        data => $ping_data,
        interval => $ping_interval,
    };
}
debugf "Configured ping: %s", ($ping || 'undefined');

#TODO daemonize here (when specified by option in UNIX like system)
#TODO use Win32::Detached ?

sub main {
    my $agent = Fluent::Agent->new(
        input => $input,
        output => $output,
        filter => $filter,
        ping => $ping,
        buffers => undef, #TODO mmmmm.....
    );
    $agent->execute(
        checker => {
            term => $checker_terminated,
            reload => $checker_reload,
        },
    );
}

infof "Starting fluent-agent.";

main();

infof "Exiting fluent-agent.";

exit 0;

__END__

=head1 NAME

fluent-agent  - Fluentd Agent tools, perl implementation

=head1 SYNOPSIS

fluent-agent [options]

  Global Options:

    B<-d,--daemonize> Run in background(daemonized)
    B<-L,--log FILEPATH>    Output fluent-agent's log into I<FILEPATH> (if not specified, dropped)

    B<-h,--help>    Brief help message
    B<-v,--verbose> Output fluent-agent logs of all (DEBUG/INFO/WARN/CRIT, default + DEBUG)
    B<-q,--quiet>   Output fluent-agent logs of WARN/CRIT only (default: INFO/WARN/CRIT)

    B<-P TAG:DATA:INTERVAL> Ping message tag/data/interval. Use with forwarding options.
    B<--ping>              Equivalent to B<-P>

  Input Options:

    B<-i FILEPATH> Read messages from I<FILEPATH>
                     (MUST BE SPECIFIED with B<-I> and B<-t> or B<-T>, exclusive with B<-p>)
    B<-I REGEXP>     Parse regexp pattern, use with B<-i>
    B<-t TAG>      Tag of input log lines (exclusive with B<-T>)
    B<-T FIELD>    Field name of tag string, from REGEXP named captures
    B<-w PATTERN>  Time format (strptime format string) to parse time of log
                     (Without this option, time is set as current time)
    B<-W FIELD>    Field name of time, from REGEXP named captures (default: time)

    B<-p PORT>     read messages from I<PORT> (compatible with fluentd's forward input)

    B<--input-file>    Equivalent to B<-i>
    B<--input-pattern> Equivalent to B<-I>
    B<--tag>           Equivalent to B<-t>
    B<--tag-field>     Equivalent to B<-T>
    B<--time-format>   Equivalent to B<-w>
    B<--time-field>    Equivalent to B<-W>

    B<--input-port>    Equivalent to B<-p>

  Output Options:

    B<-o FILEPATH>  Write messages to I<FILEPATH> with TAB separated time, tag and JSON of message
                      (exclusive with B<-f> and B<-s>)
                      FILEPATH parsed as format string like 'strftime' (ex: %Y, %m, %d, %H, %M, %S)
    B<-f HOST:PORT> Forward messages to primary server(s), specified by HOST:PORT
    B<-s HOST:PORT> Forward messages to secondary server(s) when primary servers are down

    B<--output-file>       Equivalent to B<-o>
    B<--forward-primary>   Equivalent to B<-f>
    B<--forward-secondary> Equivalent to B<-s>

  Filter Options:

    B<-x COMMAND>   Filter message between input and output, with executed I<COMMAND>'s STDIN and STDOUT
                      (equivalent with Fluentd's out_exec_filter)
    B<-X NUM>       Number of filter child processes (number of forks)
    B<--x-respawn>  Respawn childs which unexpectedly died (default: main process also dies)

    B<--x-json>     (Default) Serialize/Deserialize messages with JSON
                             (with attributes 'time' and 'tag') on STDIN/STDOUT of filter
    B<--x-msgpack>  Serialize/Deserialize messages with MessagePack

    B<--x-tsv-in KEYS>
                    Serialize messages with TSV on STDIN of filter, fields named by I<KEYS>
    B<--x-tsv-out KEYS>
                    Deserialize messages with TSV on STDOUT of filter, fields named by I<KEYS>

    B<--x-in-time-field FIELDNAME>
                    Serialize messages with time field named as I<FIELDNAME>
    B<--x-out-time-field FIELDNAME>
                    Deerialize messages with time field named as I<FIELDNAME>
    B<--x-time-field FIELDNAME>
                    Same as B<--x-in-time-field FIELDNAME --x-out-time-field FIELDNAME>

    B<--x-tag-field FIELDNAME>
                    Serialize messages with tag field named as I<FIELDNAME>
    B<--x-in-tag-field FIELDNAME>
                    Deserialize messages with tag field named as I<FIELDNAME>
    B<--x-out-tag-field FIELDNAME>
                    Same as B<--x-in-tag-field FIELDNAME --x-out-tag-field FIELDNAME>

    B<--x-remove-prefix TAG_PREFIX>
                    Remove tag prefix before serialization for filter's STDIN
    B<--x-add-prefix TAG_PREFIX>
                    Add tag prefix after deserialization for filter's STDOUT

=head1 OPTIONS

=over 8

=item B<-help>

Print a brief help message and exits.

=back

=head1 DESCRIPTION

B<This program> will read the given input file(s) and do something
useful with the contents thereof.

=cut
